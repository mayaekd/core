%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Core Model, 2022
% Written by Maya Davis
% Concept by Maya Davis and Melissa A. Redford
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% METHODS TESTED
%  Space
%  ClusterToJunctureActivations
%  AverageJuncture
%  MotorClusterPlottingInfo
%  PerceptualClusterPlottingInfo
%  MotorClusterPlottingInfo3D
%  PerceptualClusterPlottingInfo3D

%% TESTS

function tests = TestSpaceSimple
    tests = functiontests(localfunctions);
end

function TestCreateObjectSimple(testCase)
    st1 = testCase.TestData.spaceTransformation1;
    Clusters1 = MakeManyHyperCubeClusters([0 0], [1 1], [2 3], ...
        [4 4], [1 2], st1);
    Space1 = Space(Clusters1, st1);

    %% JUNCTURE LISTS

    actCanonicalJuncture1Motor = Space1.CanonicalJunctureOrder(1).MotorPoint.Coordinates;
    actCanonicalJuncture2Motor = Space1.CanonicalJunctureOrder(2).MotorPoint.Coordinates;
    actCanonicalJuncture3Motor = Space1.CanonicalJunctureOrder(3).MotorPoint.Coordinates;
    actCanonicalJuncture4Motor = Space1.CanonicalJunctureOrder(4).MotorPoint.Coordinates;
    actCanonicalJuncture5Motor = Space1.CanonicalJunctureOrder(5).MotorPoint.Coordinates;
    actCanonicalJuncture6Motor = Space1.CanonicalJunctureOrder(6).MotorPoint.Coordinates;
    actCanonicalJuncture7Motor = Space1.CanonicalJunctureOrder(7).MotorPoint.Coordinates;
    actCanonicalJuncture8Motor = Space1.CanonicalJunctureOrder(8).MotorPoint.Coordinates;
    actCanonicalJuncture9Motor = Space1.CanonicalJunctureOrder(9).MotorPoint.Coordinates;
    actCanonicalJuncture10Motor = Space1.CanonicalJunctureOrder(10).MotorPoint.Coordinates;
    actCanonicalJuncture11Motor = Space1.CanonicalJunctureOrder(11).MotorPoint.Coordinates;
    actCanonicalJuncture12Motor = Space1.CanonicalJunctureOrder(12).MotorPoint.Coordinates;
    actCanonicalJuncture13Perceptual = Space1.CanonicalJunctureOrder(13).PerceptualPoint.Coordinates;
    actCanonicalJuncture14Perceptual = Space1.CanonicalJunctureOrder(14).PerceptualPoint.Coordinates;
    actCanonicalJuncture15Perceptual = Space1.CanonicalJunctureOrder(15).PerceptualPoint.Coordinates;
    actCanonicalJuncture16Perceptual = Space1.CanonicalJunctureOrder(16).PerceptualPoint.Coordinates;
    actCanonicalJuncture17Perceptual = Space1.CanonicalJunctureOrder(17).PerceptualPoint.Coordinates;
    actCanonicalJuncture18Perceptual = Space1.CanonicalJunctureOrder(18).PerceptualPoint.Coordinates;
    actCanonicalJuncture19Perceptual = Space1.CanonicalJunctureOrder(19).PerceptualPoint.Coordinates;
    actCanonicalJuncture20Perceptual = Space1.CanonicalJunctureOrder(20).PerceptualPoint.Coordinates;
    actCanonicalJuncture21Perceptual = Space1.CanonicalJunctureOrder(21).PerceptualPoint.Coordinates;
    actCanonicalJuncture22Perceptual = Space1.CanonicalJunctureOrder(22).PerceptualPoint.Coordinates;
    actCanonicalJuncture23Perceptual = Space1.CanonicalJunctureOrder(23).PerceptualPoint.Coordinates;
    actCanonicalJuncture24Perceptual = Space1.CanonicalJunctureOrder(24).PerceptualPoint.Coordinates;

    expCanonicalJuncture1Motor = [0; 0];
    expCanonicalJuncture2Motor = [1; 0];
    expCanonicalJuncture3Motor = [2; 0];
    expCanonicalJuncture4Motor = [0; 1];
    expCanonicalJuncture5Motor = [1; 1];
    expCanonicalJuncture6Motor = [2; 1];
    expCanonicalJuncture7Motor = [0; 2];
    expCanonicalJuncture8Motor = [1; 2];
    expCanonicalJuncture9Motor = [2; 2];
    expCanonicalJuncture10Motor = [0; 3];
    expCanonicalJuncture11Motor = [1; 3];
    expCanonicalJuncture12Motor = [2; 3];
    expCanonicalJuncture13Perceptual = [0; 7];
    expCanonicalJuncture14Perceptual = [1; 7];
    expCanonicalJuncture15Perceptual = [2; 7];
    expCanonicalJuncture16Perceptual = [0; 8];
    expCanonicalJuncture17Perceptual = [1; 8];
    expCanonicalJuncture18Perceptual = [2; 8];
    expCanonicalJuncture19Perceptual = [0; 9];
    expCanonicalJuncture20Perceptual = [1; 9];
    expCanonicalJuncture21Perceptual = [2; 9];
    expCanonicalJuncture22Perceptual = [0; 10];
    expCanonicalJuncture23Perceptual = [1; 10];
    expCanonicalJuncture24Perceptual = [2; 10];

    %% EVERYTHING ELSE
    actMotor1 = Space1.Clusters(1).MotorCoordinateMatrix;
    actMotor2 = Space1.Clusters(2).MotorCoordinateMatrix;
    
    actPerceptual1 = Space1.Clusters(1).PerceptualCoordinateMatrix;
    actPerceptual2 = Space1.Clusters(2).PerceptualCoordinateMatrix;

    actClusterSizes = Space1.ClusterSizes;

    Input1 = [1; 4; 3; 5; 8];
    Input2 = [10; 8];

    actSpaceTransformation1 = Space1.SpaceTransformation.TransformationFunction(Input1);
    actSpaceTransformation2 = Space1.SpaceTransformation.TransformationFunction(Input2);

    actMaxDistanceM = Space1.MaxDistanceWithActivationM;
    actMaxDistanceP = Space1.MaxDistanceWithActivationP;

    expMotor1 = [0 1 2 0 1 2 0 1 2 0 1 2; 0 0 0 1 1 1 2 2 2 3 3 3];
    expMotor2 = [0 1 2 0 1 2 0 1 2 0 1 2; 7 7 7 8 8 8 9 9 9 10 10 10];

    expPerceptual1 = [0 1 2 0 1 2 0 1 2 0 1 2; 0 0 0 1 1 1 2 2 2 3 3 3];
    expPerceptual2 = [0 1 2 0 1 2 0 1 2 0 1 2; 7 7 7 8 8 8 9 9 9 10 10 10];

    expClusterSizes = [12 12];

    expSpaceTransformation1 = [1; 4; 3; 5; 8];
    expSpaceTransformation2 = [10; 8];

    expMaxDistanceM = 10;
    expMaxDistanceP = 10;

    %% JUNCTURE TESTS

    verifyEqual(testCase, actCanonicalJuncture1Motor, expCanonicalJuncture1Motor);
    verifyEqual(testCase, actCanonicalJuncture2Motor, expCanonicalJuncture2Motor);
    verifyEqual(testCase, actCanonicalJuncture3Motor, expCanonicalJuncture3Motor);
    verifyEqual(testCase, actCanonicalJuncture4Motor, expCanonicalJuncture4Motor);
    verifyEqual(testCase, actCanonicalJuncture5Motor, expCanonicalJuncture5Motor);
    verifyEqual(testCase, actCanonicalJuncture6Motor, expCanonicalJuncture6Motor);
    verifyEqual(testCase, actCanonicalJuncture7Motor, expCanonicalJuncture7Motor);
    verifyEqual(testCase, actCanonicalJuncture8Motor, expCanonicalJuncture8Motor);
    verifyEqual(testCase, actCanonicalJuncture9Motor, expCanonicalJuncture9Motor);
    verifyEqual(testCase, actCanonicalJuncture10Motor, expCanonicalJuncture10Motor);
    verifyEqual(testCase, actCanonicalJuncture11Motor, expCanonicalJuncture11Motor);
    verifyEqual(testCase, actCanonicalJuncture12Motor, expCanonicalJuncture12Motor);
    verifyEqual(testCase, actCanonicalJuncture13Perceptual, expCanonicalJuncture13Perceptual);
    verifyEqual(testCase, actCanonicalJuncture14Perceptual, expCanonicalJuncture14Perceptual);
    verifyEqual(testCase, actCanonicalJuncture15Perceptual, expCanonicalJuncture15Perceptual);
    verifyEqual(testCase, actCanonicalJuncture16Perceptual, expCanonicalJuncture16Perceptual);
    verifyEqual(testCase, actCanonicalJuncture17Perceptual, expCanonicalJuncture17Perceptual);
    verifyEqual(testCase, actCanonicalJuncture18Perceptual, expCanonicalJuncture18Perceptual);
    verifyEqual(testCase, actCanonicalJuncture19Perceptual, expCanonicalJuncture19Perceptual);
    verifyEqual(testCase, actCanonicalJuncture20Perceptual, expCanonicalJuncture20Perceptual);
    verifyEqual(testCase, actCanonicalJuncture21Perceptual, expCanonicalJuncture21Perceptual);
    verifyEqual(testCase, actCanonicalJuncture22Perceptual, expCanonicalJuncture22Perceptual);
    verifyEqual(testCase, actCanonicalJuncture23Perceptual, expCanonicalJuncture23Perceptual);
    verifyEqual(testCase, actCanonicalJuncture24Perceptual, expCanonicalJuncture24Perceptual);

    %% REST OF TESTS
    verifyEqual(testCase, actMotor1, expMotor1);
    verifyEqual(testCase, actMotor2, expMotor2);
    verifyEqual(testCase, actPerceptual1, expPerceptual1);
    verifyEqual(testCase, actPerceptual2, expPerceptual2);

    verifyEqual(testCase, actClusterSizes, expClusterSizes);
    
    verifyEqual(testCase, actSpaceTransformation1, expSpaceTransformation1);
    verifyEqual(testCase, actSpaceTransformation2, expSpaceTransformation2);

    verifyEqual(testCase, actMaxDistanceM, expMaxDistanceM);
    verifyEqual(testCase, actMaxDistanceP, expMaxDistanceP);
end

function TestClusterToJunctureActivationsSimple(testCase)
    st1 = testCase.TestData.spaceTransformation1;
    Clusters1 = MakeManyHyperCubeClusters([0 0], [1 1], [2 3], ...
        [4 4], [1 2], st1);
    Space1 = Space(Clusters1, st1);
    ClusterActivations1 = [5 16];

    Clusters2 = MakeManyHyperCubeClusters([3 99], [1 1], [2 4], ...
        [300 30], [3 4], st1);
    Space2 = Space(Clusters2, st1);
    ClusterActivations2 = [2 4 6 8 10 12 1 3 5 7 9 11];

    actJunctureActivations1 = Space1.ClusterToJunctureActivations(ClusterActivations1);
    expJunctureActivations1 = [5 5 5 5 5 5 5 5 5 5 5 5 16 16 16 16 16 16 16 16 16 16 16 16];

    actJunctureActivations2 = Space2.ClusterToJunctureActivations(ClusterActivations2);
    expJunctureActivations2 = [...
        2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ...
        4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 ...
        6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 ...
        8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 ...
        10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 ...
        12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 ...
        1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
        3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 ...
        5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 ...
        7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 ...
        9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 ...
        11 11 11 11 11 11 11 11 11 11 11 11 11 11 11];
    verifyEqual(testCase, actJunctureActivations1, expJunctureActivations1);
    verifyEqual(testCase, actJunctureActivations2, expJunctureActivations2);
end

function TestAverageJunctureSimple(testCase)
    st1 = testCase.TestData.spaceTransformation1;
    Clusters1 = MakeManyHyperCubeClusters([0 0], [1 1], [2 3], ...
        [4 4], [1 2], st1);
    Space1 = Space(Clusters1, st1);

    actAverage1 = Space1.AverageJuncture([1 1 1 1 1 1 1 1 1 1 1 1 ...
        0 0 0 0 0 0 0 0 0 0 0 0]);
    actAverage2 = Space1.AverageJuncture([0 0 0 0 0 0 0 0 0 0 0 0 ...
        5 5 5 5 5 5 5 5 5 5 5 5]);
    actAverage3 = Space1.AverageJuncture([1 1 1 1 1 1 1 1 1 1 1 1 ...
        6 6 6 6 6 6 6 6 6 6 6 6]);

    actAverage1M = actAverage1.MotorPoint.Coordinates;
    actAverage2M = actAverage2.MotorPoint.Coordinates;
    actAverage3M = actAverage3.MotorPoint.Coordinates;

    actAverage1P = actAverage1.PerceptualPoint.Coordinates;
    actAverage2P = actAverage2.PerceptualPoint.Coordinates;
    actAverage3P = actAverage3.PerceptualPoint.Coordinates;

    expAverage1M = [1; 1.5];
    expAverage2M = [1; 8.5];
    expAverage3M = [1; 7.5];

    expAverage1P = [1; 1.5];
    expAverage2P = [1; 8.5];
    expAverage3P = [1; 7.5];

    verifyEqual(testCase, actAverage1M, expAverage1M);
    verifyEqual(testCase, actAverage2M, expAverage2M);
    verifyEqual(testCase, actAverage3M, expAverage3M);

    verifyEqual(testCase, actAverage1P, expAverage1P);
    verifyEqual(testCase, actAverage2P, expAverage2P);
    verifyEqual(testCase, actAverage3P, expAverage3P);
end

function TestMotorClusterPlottingInfoSimple(testCase)
    st2 = testCase.TestData.spaceTransformation2;
    Clusters1 = MakeManyHyperCubeClusters([0 0], [1 1], [2 3], ...
        [4 4], [1 2], st2);
    Space1 = Space(Clusters1, st2);
    ColorArray = [0.2 0.3 1; 1 0 1];
    AlphaClusterValues = [0.8; 1];
    [actXValues, actYValues, actColorValues, actAlphaValues] = ...
        Space1.MotorClusterPlottingInfo(ColorArray, AlphaClusterValues);
    expXValues = [0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2];
    expYValues = [0 0 0 1 1 1 2 2 2 3 3 3 7 7 7 8 8 8 9 9 9 10 10 10];
    expColorValues = [0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1];
    expAlphaValues = [0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        1 1 1 1 1 1 1 1 1 1 1 1];
    verifyEqual(testCase, actXValues, expXValues);
    verifyEqual(testCase, actYValues, expYValues);
    verifyEqual(testCase, actColorValues, expColorValues);
    verifyEqual(testCase, actAlphaValues, expAlphaValues);
end

function TestPerceptualClusterPlottingInfoSimple(testCase)
    st2 = testCase.TestData.spaceTransformation2;
    Clusters1 = MakeManyHyperCubeClusters([0 0], [1 1], [2 3], ...
        [4 4], [1 2], st2);
    Space1 = Space(Clusters1, st2);
    ColorArray = [0.2 0.3 1; 1 0 1];
    AlphaClusterValues = [0.8; 1];
    [actXValues, actYValues, actColorValues, actAlphaValues] = ...
        Space1.PerceptualClusterPlottingInfo(ColorArray, AlphaClusterValues);
    expXValues = [10 9 8 10 9 8 10 9 8 10 9 8 ...
        10 9 8 10 9 8 10 9 8 10 9 8];
    expYValues = [10 10 10 9 9 9 8 8 8 7 7 7 ...
        3 3 3 2 2 2 1 1 1 0 0 0];
    expColorValues = [0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1];
    expAlphaValues = [0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        1 1 1 1 1 1 1 1 1 1 1 1];
    verifyEqual(testCase, actXValues, expXValues);
    verifyEqual(testCase, actYValues, expYValues);
    verifyEqual(testCase, actColorValues, expColorValues);
    verifyEqual(testCase, actAlphaValues, expAlphaValues);
end

function TestMotorClusterPlottingInfo3DSimple(testCase)
    st2 = testCase.TestData.spaceTransformation2;
    Clusters1 = MakeManyHyperCubeClusters([0 0 0], [1 1 2], [2 3 2], ...
        [4 4 6], [1 2 2], st2, "zMotorRowIndex", 3, "zPerceptualRowIndex", 3);
    Space1 = Space(Clusters1, st2);
    ColorArray = [0.2 0.3 1; 1 0 1; 1 0 0; 0 1 1];
    AlphaClusterValues = [0.8; 1; 0.6; 0.78];
    [actXValues, actYValues, actZValues, actColorValues, actAlphaValues] = ...
        Space1.MotorClusterPlottingInfo3D(ColorArray, AlphaClusterValues);
    
    expXValues = [...
        0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 ...
        0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 ...
        0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 ...
        0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 ...
        ];
    expYValues = [...
        0 0 0 1 1 1 2 2 2 3 3 3 0 0 0 1 1 1 2 2 2 3 3 3 ...
        7 7 7 8 8 8 9 9 9 10 10 10 7 7 7 8 8 8 9 9 9 10 10 10 ...
        0 0 0 1 1 1 2 2 2 3 3 3 0 0 0 1 1 1 2 2 2 3 3 3 ...
        7 7 7 8 8 8 9 9 9 10 10 10 7 7 7 8 8 8 9 9 9 10 10 10 ...
        ];
    expZValues = [...
        0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 ...
        0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 ...
        8 8 8 8 8 8 8 8 8 8 8 8 10 10 10 10 10 10 10 10 10 10 10 10 ...
        8 8 8 8 8 8 8 8 8 8 8 8 10 10 10 10 10 10 10 10 10 10 10 10 ...
        ];
    expColorValues = [...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1];
    expAlphaValues = [...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        1 1 1 1 1 1 1 1 1 1 1 1 ...
        1 1 1 1 1 1 1 1 1 1 1 1 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.78 0.78 0.78 0.78 0.78 0.78 ...
        0.78 0.78 0.78 0.78 0.78 0.78 ...
        0.78 0.78 0.78 0.78 0.78 0.78 ...
        0.78 0.78 0.78 0.78 0.78 0.78];
    verifyEqual(testCase, actXValues, expXValues);
    verifyEqual(testCase, actYValues, expYValues);
    verifyEqual(testCase, actZValues, expZValues);
    verifyEqual(testCase, actColorValues, expColorValues);
    verifyEqual(testCase, actAlphaValues, expAlphaValues);
end

function TestPerceptualClusterPlottingInfo3DSimple(testCase)
    st2 = testCase.TestData.spaceTransformation2;
    Clusters1 = MakeManyHyperCubeClusters([0 0 0], [1 1 2], [2 3 2], ...
        [4 4 6], [1 2 2], st2, "zMotorRowIndex", 3, "zPerceptualRowIndex", 3);
    Space1 = Space(Clusters1, st2);
    ColorArray = [0.2 0.3 1; 1 0 1; 1 0 0; 0 1 1];
    AlphaClusterValues = [0.8; 1; 0.6; 0.78];
    [actXValues, actYValues, actZValues, actColorValues, actAlphaValues] = ...
        Space1.PerceptualClusterPlottingInfo3D(ColorArray, AlphaClusterValues);
    
    expXValues = [...
        10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 ...
        10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 ...
        10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 ...
        10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 10 9 8 ...
        ];
    expYValues = [...
        10 10 10 9 9 9 8 8 8 7 7 7 10 10 10 9 9 9 8 8 8 7 7 7 ...
        3 3 3 2 2 2 1 1 1 0 0 0 3 3 3 2 2 2 1 1 1 0 0 0 ...
        10 10 10 9 9 9 8 8 8 7 7 7 10 10 10 9 9 9 8 8 8 7 7 7 ...
        3 3 3 2 2 2 1 1 1 0 0 0 3 3 3 2 2 2 1 1 1 0 0 0 ...
        ];
    expZValues = [...
        10 10 10 10 10 10 10 10 10 10 10 10 8 8 8 8 8 8 8 8 8 8 8 8 ...
        10 10 10 10 10 10 10 10 10 10 10 10 8 8 8 8 8 8 8 8 8 8 8 8 ...
        2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 ...
        2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 ...
        ];
    expColorValues = [...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; 0.2 0.3 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 1; 1 0 1; 1 0 1; 1 0 1; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        1 0 0; 1 0 0; 1 0 0; 1 0 0; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1; ...
        0 1 1; 0 1 1; 0 1 1; 0 1 1];
    expAlphaValues = [...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        0.8 0.8 0.8 0.8 0.8 0.8 ...
        1 1 1 1 1 1 1 1 1 1 1 1 ...
        1 1 1 1 1 1 1 1 1 1 1 1 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.6 0.6 0.6 0.6 0.6 0.6 ...
        0.78 0.78 0.78 0.78 0.78 0.78 ...
        0.78 0.78 0.78 0.78 0.78 0.78 ...
        0.78 0.78 0.78 0.78 0.78 0.78 ...
        0.78 0.78 0.78 0.78 0.78 0.78];
    verifyEqual(testCase, actXValues, expXValues);
    verifyEqual(testCase, actYValues, expYValues);
    verifyEqual(testCase, actZValues, expZValues);
    verifyEqual(testCase, actColorValues, expColorValues);
    verifyEqual(testCase, actAlphaValues, expAlphaValues);
end

%% SETTING UP AND TEARING DOWN
function setupOnce(testCase)
    % Create and change to temporary folder
    testCase.TestData.origPath = pwd;
    testCase.TestData.tmpFolder = "tmpFolder" + ...
        string(datetime('now','Format',"yyyyMMdd'T'HHmmss"));
    mkdir(testCase.TestData.tmpFolder)
    cd(testCase.TestData.tmpFolder)
    % Create and save variables

    % SPACE TRANSFORMATIONS
    testCase.TestData.spaceTransformation1 = SpaceTransformation(@transformationFunction1);
    testCase.TestData.spaceTransformation2 = SpaceTransformation(@transformationFunction2);
    testCase.TestData.spaceTransformation3 = SpaceTransformation(@transformationFunction3);
end

function teardownOnce(testCase)
    cd(testCase.TestData.origPath)
    rmdir(testCase.TestData.tmpFolder)
end

function PerceptualCoordinates = transformationFunction1(MotorCoordinates)
    PerceptualCoordinates = MotorCoordinates;
end

function PerceptualCoordinates = transformationFunction2(MotorCoordinates)
    PerceptualCoordinates = 10 - MotorCoordinates;
end

function PerceptualCoordinates = transformationFunction3(MotorCoordinates)
    MX = MotorCoordinates(1,1);
    MY = MotorCoordinates(2,1);
    if MY < 11
        PX = MX;
        PY = MY;
    else
        if MX < 18
            PX = MX + 10;
            PY = MY;
        else
            PX = MX - 20;
            PY = MY;
        end
    end
    PerceptualCoordinates = [PX; PY];
end
